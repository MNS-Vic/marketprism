#!/usr/bin/env python3
"""
事件循环问题修复脚本

这个脚本会自动修复MarketPrism项目中的事件循环关闭问题，
通过应用异步资源管理器来确保所有异步资源正确清理。
"""

import os
import re
import sys
from pathlib import Path
from typing import List, Dict, Any


class EventLoopFixer:
    """事件循环问题修复器"""
    
    def __init__(self, project_root: str):
        self.project_root = Path(project_root)
        self.test_dirs = [
            self.project_root / "tests",
        ]
        self.fixed_files = []
        self.errors = []
        
    def find_async_test_files(self) -> List[Path]:
        """查找包含异步测试的文件"""
        async_test_files = []
        
        for test_dir in self.test_dirs:
            if test_dir.exists():
                for file_path in test_dir.rglob("test_*.py"):
                    try:
                        content = file_path.read_text(encoding='utf-8')
                        if self._has_async_tests(content):
                            async_test_files.append(file_path)
                    except Exception as e:
                        self.errors.append(f"读取文件失败 {file_path}: {e}")
                        
        return async_test_files
    
    def _has_async_tests(self, content: str) -> bool:
        """检查文件是否包含异步测试"""
        patterns = [
            r'@pytest\.mark\.asyncio',
            r'async def test_',
            r'await\s+\w+',
            r'asyncio\.',
            r'aiohttp\.',
            r'nats\.',
        ]
        
        for pattern in patterns:
            if re.search(pattern, content):
                return True
        return False
    
    def fix_file(self, file_path: Path) -> bool:
        """修复单个文件的事件循环问题"""
        try:
            content = file_path.read_text(encoding='utf-8')
            original_content = content
            
            # 1. 添加异步资源管理器导入
            content = self._add_async_resource_imports(content)
            
            # 2. 修复异步测试方法
            content = self._fix_async_test_methods(content)
            
            # 3. 添加警告抑制
            content = self._add_warning_suppression(content)
            
            if content != original_content:
                # 备份原文件
                backup_path = file_path.with_suffix('.py.backup')
                backup_path.write_text(original_content, encoding='utf-8')
                
                # 写入修复后的内容
                file_path.write_text(content, encoding='utf-8')
                self.fixed_files.append(str(file_path))
                return True
                
        except Exception as e:
            self.errors.append(f"修复文件失败 {file_path}: {e}")
            
        return False
    
    def _add_async_resource_imports(self, content: str) -> str:
        """添加异步资源管理器导入"""
        # 检查是否已经导入
        if 'async_resource_manager' in content:
            return content
            
        # 查找导入部分
        import_pattern = r'(from marketprism_collector\..*?\n)'
        
        async_imports = '''
# 导入异步资源管理器
from tests.tdd_framework.async_resource_manager import (
    safe_async_test, auto_cleanup_async_resources, suppress_event_loop_warnings
)


'''
        
        # 在最后一个from marketprism_collector导入后添加
        def replace_func(match):
            return match.group(1) + async_imports
            
        new_content = re.sub(import_pattern, replace_func, content, count=1)
        
        # 如果没有找到marketprism_collector导入，在import部分末尾添加
        if new_content == content:
            import_end_pattern = r'(import .*?\n)(\n*class|\n*def|\n*@|\n*$)'
            new_content = re.sub(
                import_end_pattern, 
                r'\1' + async_imports + r'\2', 
                content, 
                count=1
            )
            
        return new_content
    
    def _fix_async_test_methods(self, content: str) -> str:
        """修复异步测试方法"""
        # 查找异步测试方法
        async_test_pattern = r'(@pytest\.mark\.asyncio\s+async def test_\w+\([^)]*\):\s*"""[^"]*"""\s*)(.*?)(?=\n    @|\n    def|\nclass|\n\n\nclass|\Z)'
        
        def fix_async_method(match):
            method_header = match.group(1)
            method_body = match.group(2)
            
            # 检查是否已经使用了safe_async_test
            if 'safe_async_test' in method_body:
                return match.group(0)
            
            # 重新缩进方法体
            lines = method_body.split('\n')
            indented_lines = []
            
            for line in lines:
                if line.strip():
                    # 增加4个空格的缩进
                    indented_lines.append('    ' + line)
                else:
                    indented_lines.append(line)
            
            indented_body = '\n'.join(indented_lines)
            
            # 包装在safe_async_test中
            new_body = f'''        async with safe_async_test() as fixture:
{indented_body}'''
            
            return method_header + new_body
        
        return re.sub(async_test_pattern, fix_async_method, content, flags=re.DOTALL)
    
    def _add_warning_suppression(self, content: str) -> str:
        """添加警告抑制"""
            return content
            
        # 在类定义前添加警告抑制
        class_pattern = r'(\n\nclass Test)'
        
        return re.sub(class_pattern, replacement, content, count=1)
    
    def create_pytest_plugin(self):
        """创建pytest插件来处理事件循环清理"""
        plugin_content = '''"""
pytest插件 - 事件循环清理

这个插件确保每个测试后都正确清理异步资源
"""

import pytest
import asyncio
import warnings
from tests.tdd_framework.async_resource_manager import cleanup_global_resources


def pytest_configure(config):
    """配置pytest"""
    # 抑制事件循环相关警告
    warnings.filterwarnings(
        "ignore",
        message="There is no current event loop",
        category=DeprecationWarning
    )
    warnings.filterwarnings(
        "ignore", 
        message="pytest-asyncio detected an unclosed event loop",
        category=DeprecationWarning
    )
    warnings.filterwarnings(
        "ignore",
        message="Exception ignored in.*Event loop is closed",
        category=RuntimeWarning
    )


def pytest_runtest_teardown(item, nextitem):
    """每个测试后的清理"""
    try:
        # 清理全局异步资源
        loop = asyncio.get_event_loop()
        if not loop.is_closed():
            loop.run_until_complete(cleanup_global_resources())
    except Exception:
        pass  # 忽略清理错误


@pytest.fixture(autouse=True)
async def auto_cleanup():
    """自动清理fixture"""
    yield
    # 测试后清理
    try:
        await cleanup_global_resources()
    except Exception:
        pass
'''
        
        plugin_path = self.project_root / "tests" / "conftest.py"
        
        # 如果conftest.py已存在，追加内容
        if plugin_path.exists():
            existing_content = plugin_path.read_text(encoding='utf-8')
            if 'async_resource_manager' not in existing_content:
                plugin_path.write_text(existing_content + '\n\n' + plugin_content, encoding='utf-8')
        else:
            plugin_path.write_text(plugin_content, encoding='utf-8')
            
        print(f"✅ 创建/更新pytest插件: {plugin_path}")
    
    def run_fix(self) -> Dict[str, Any]:
        """运行修复"""
        print("🔧 开始修复事件循环问题...")
        
        # 1. 查找异步测试文件
        async_files = self.find_async_test_files()
        print(f"📁 找到 {len(async_files)} 个包含异步测试的文件")
        
        # 2. 修复每个文件
        for file_path in async_files:
            print(f"🔨 修复文件: {file_path}")
            self.fix_file(file_path)
        
        # 3. 创建pytest插件
        self.create_pytest_plugin()
        
        # 4. 返回结果
        result = {
            'fixed_files': len(self.fixed_files),
            'total_files': len(async_files),
            'errors': len(self.errors),
            'success_rate': len(self.fixed_files) / len(async_files) * 100 if async_files else 0
        }
        
        print(f"\n📊 修复结果:")
        print(f"   ✅ 成功修复: {result['fixed_files']}/{result['total_files']} 文件")
        print(f"   📈 成功率: {result['success_rate']:.1f}%")
        print(f"   ❌ 错误数: {result['errors']}")
        
        if self.errors:
            print(f"\n❗ 错误详情:")
            for error in self.errors:
                print(f"   - {error}")
        
        return result


def main():
    """主函数"""
    if len(sys.argv) > 1:
        project_root = sys.argv[1]
    else:
        project_root = os.getcwd()
    
    print(f"🚀 MarketPrism事件循环问题修复器")
    print(f"📂 项目根目录: {project_root}")
    
    fixer = EventLoopFixer(project_root)
    result = fixer.run_fix()
    
    if result['success_rate'] > 80:
        print(f"\n🎉 修复成功！事件循环问题已基本解决")
        return 0
    else:
        print(f"\n⚠️  修复部分成功，请检查错误信息")
        return 1


if __name__ == "__main__":
    sys.exit(main())