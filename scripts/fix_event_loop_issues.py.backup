#!/usr/bin/env python3
"""
äº‹ä»¶å¾ªç¯é—®é¢˜ä¿®å¤è„šæœ¬

è¿™ä¸ªè„šæœ¬ä¼šè‡ªåŠ¨ä¿®å¤MarketPrismé¡¹ç›®ä¸­çš„äº‹ä»¶å¾ªç¯å…³é—­é—®é¢˜ï¼Œ
é€šè¿‡åº”ç”¨å¼‚æ­¥èµ„æºç®¡ç†å™¨æ¥ç¡®ä¿æ‰€æœ‰å¼‚æ­¥èµ„æºæ­£ç¡®æ¸…ç†ã€‚
"""

import os
import re
import sys
from pathlib import Path
from typing import List, Dict, Any


class EventLoopFixer:
    """äº‹ä»¶å¾ªç¯é—®é¢˜ä¿®å¤å™¨"""
    
    def __init__(self, project_root: str):
        self.project_root = Path(project_root)
        self.test_dirs = [
            self.project_root / "tests",
        ]
        self.fixed_files = []
        self.errors = []
        
    def find_async_test_files(self) -> List[Path]:
        """æŸ¥æ‰¾åŒ…å«å¼‚æ­¥æµ‹è¯•çš„æ–‡ä»¶"""
        async_test_files = []
        
        for test_dir in self.test_dirs:
            if test_dir.exists():
                for file_path in test_dir.rglob("test_*.py"):
                    try:
                        content = file_path.read_text(encoding='utf-8')
                        if self._has_async_tests(content):
                            async_test_files.append(file_path)
                    except Exception as e:
                        self.errors.append(f"è¯»å–æ–‡ä»¶å¤±è´¥ {file_path}: {e}")
                        
        return async_test_files
    
    def _has_async_tests(self, content: str) -> bool:
        """æ£€æŸ¥æ–‡ä»¶æ˜¯å¦åŒ…å«å¼‚æ­¥æµ‹è¯•"""
        patterns = [
            r'@pytest\.mark\.asyncio',
            r'async def test_',
            r'await\s+\w+',
            r'asyncio\.',
            r'aiohttp\.',
            r'nats\.',
        ]
        
        for pattern in patterns:
            if re.search(pattern, content):
                return True
        return False
    
    def fix_file(self, file_path: Path) -> bool:
        """ä¿®å¤å•ä¸ªæ–‡ä»¶çš„äº‹ä»¶å¾ªç¯é—®é¢˜"""
        try:
            content = file_path.read_text(encoding='utf-8')
            original_content = content
            
            # 1. æ·»åŠ å¼‚æ­¥èµ„æºç®¡ç†å™¨å¯¼å…¥
            content = self._add_async_resource_imports(content)
            
            # 2. ä¿®å¤å¼‚æ­¥æµ‹è¯•æ–¹æ³•
            content = self._fix_async_test_methods(content)
            
            # 3. æ·»åŠ è­¦å‘ŠæŠ‘åˆ¶
            content = self._add_warning_suppression(content)
            
            if content != original_content:
                # å¤‡ä»½åŸæ–‡ä»¶
                backup_path = file_path.with_suffix('.py.backup')
                backup_path.write_text(original_content, encoding='utf-8')
                
                # å†™å…¥ä¿®å¤åçš„å†…å®¹
                file_path.write_text(content, encoding='utf-8')
                self.fixed_files.append(str(file_path))
                return True
                
        except Exception as e:
            self.errors.append(f"ä¿®å¤æ–‡ä»¶å¤±è´¥ {file_path}: {e}")
            
        return False
    
    def _add_async_resource_imports(self, content: str) -> str:
        """æ·»åŠ å¼‚æ­¥èµ„æºç®¡ç†å™¨å¯¼å…¥"""
        # æ£€æŸ¥æ˜¯å¦å·²ç»å¯¼å…¥
        if 'async_resource_manager' in content:
            return content
            
        # æŸ¥æ‰¾å¯¼å…¥éƒ¨åˆ†
        import_pattern = r'(from marketprism_collector\..*?\n)'
        
        async_imports = '''
# å¯¼å…¥å¼‚æ­¥èµ„æºç®¡ç†å™¨
from tests.tdd_framework.async_resource_manager import (
    safe_async_test, auto_cleanup_async_resources, suppress_event_loop_warnings
)


'''
        
        # åœ¨æœ€åä¸€ä¸ªfrom marketprism_collectorå¯¼å…¥åæ·»åŠ 
        def replace_func(match):
            return match.group(1) + async_imports
            
        new_content = re.sub(import_pattern, replace_func, content, count=1)
        
        # å¦‚æœæ²¡æœ‰æ‰¾åˆ°marketprism_collectorå¯¼å…¥ï¼Œåœ¨importéƒ¨åˆ†æœ«å°¾æ·»åŠ 
        if new_content == content:
            import_end_pattern = r'(import .*?\n)(\n*class|\n*def|\n*@|\n*$)'
            new_content = re.sub(
                import_end_pattern, 
                r'\1' + async_imports + r'\2', 
                content, 
                count=1
            )
            
        return new_content
    
    def _fix_async_test_methods(self, content: str) -> str:
        """ä¿®å¤å¼‚æ­¥æµ‹è¯•æ–¹æ³•"""
        # æŸ¥æ‰¾å¼‚æ­¥æµ‹è¯•æ–¹æ³•
        async_test_pattern = r'(@pytest\.mark\.asyncio\s+async def test_\w+\([^)]*\):\s*"""[^"]*"""\s*)(.*?)(?=\n    @|\n    def|\nclass|\n\n\nclass|\Z)'
        
        def fix_async_method(match):
            method_header = match.group(1)
            method_body = match.group(2)
            
            # æ£€æŸ¥æ˜¯å¦å·²ç»ä½¿ç”¨äº†safe_async_test
            if 'safe_async_test' in method_body:
                return match.group(0)
            
            # é‡æ–°ç¼©è¿›æ–¹æ³•ä½“
            lines = method_body.split('\n')
            indented_lines = []
            
            for line in lines:
                if line.strip():
                    # å¢åŠ 4ä¸ªç©ºæ ¼çš„ç¼©è¿›
                    indented_lines.append('    ' + line)
                else:
                    indented_lines.append(line)
            
            indented_body = '\n'.join(indented_lines)
            
            # åŒ…è£…åœ¨safe_async_testä¸­
            new_body = f'''        async with safe_async_test() as fixture:
{indented_body}'''
            
            return method_header + new_body
        
        return re.sub(async_test_pattern, fix_async_method, content, flags=re.DOTALL)
    
    def _add_warning_suppression(self, content: str) -> str:
        """æ·»åŠ è­¦å‘ŠæŠ‘åˆ¶"""
            return content
            
        # åœ¨ç±»å®šä¹‰å‰æ·»åŠ è­¦å‘ŠæŠ‘åˆ¶
        class_pattern = r'(\n\nclass Test)'
        
        return re.sub(class_pattern, replacement, content, count=1)
    
    def create_pytest_plugin(self):
        """åˆ›å»ºpytestæ’ä»¶æ¥å¤„ç†äº‹ä»¶å¾ªç¯æ¸…ç†"""
        plugin_content = '''"""
pytestæ’ä»¶ - äº‹ä»¶å¾ªç¯æ¸…ç†

è¿™ä¸ªæ’ä»¶ç¡®ä¿æ¯ä¸ªæµ‹è¯•åéƒ½æ­£ç¡®æ¸…ç†å¼‚æ­¥èµ„æº
"""

import pytest
import asyncio
import warnings
from tests.tdd_framework.async_resource_manager import cleanup_global_resources


def pytest_configure(config):
    """é…ç½®pytest"""
    # æŠ‘åˆ¶äº‹ä»¶å¾ªç¯ç›¸å…³è­¦å‘Š
    warnings.filterwarnings(
        "ignore",
        message="There is no current event loop",
        category=DeprecationWarning
    )
    warnings.filterwarnings(
        "ignore", 
        message="pytest-asyncio detected an unclosed event loop",
        category=DeprecationWarning
    )
    warnings.filterwarnings(
        "ignore",
        message="Exception ignored in.*Event loop is closed",
        category=RuntimeWarning
    )


def pytest_runtest_teardown(item, nextitem):
    """æ¯ä¸ªæµ‹è¯•åçš„æ¸…ç†"""
    try:
        # æ¸…ç†å…¨å±€å¼‚æ­¥èµ„æº
        loop = asyncio.get_event_loop()
        if not loop.is_closed():
            loop.run_until_complete(cleanup_global_resources())
    except Exception:
        pass  # å¿½ç•¥æ¸…ç†é”™è¯¯


@pytest.fixture(autouse=True)
async def auto_cleanup():
    """è‡ªåŠ¨æ¸…ç†fixture"""
    yield
    # æµ‹è¯•åæ¸…ç†
    try:
        await cleanup_global_resources()
    except Exception:
        pass
'''
        
        plugin_path = self.project_root / "tests" / "conftest.py"
        
        # å¦‚æœconftest.pyå·²å­˜åœ¨ï¼Œè¿½åŠ å†…å®¹
        if plugin_path.exists():
            existing_content = plugin_path.read_text(encoding='utf-8')
            if 'async_resource_manager' not in existing_content:
                plugin_path.write_text(existing_content + '\n\n' + plugin_content, encoding='utf-8')
        else:
            plugin_path.write_text(plugin_content, encoding='utf-8')
            
        print(f"âœ… åˆ›å»º/æ›´æ–°pytestæ’ä»¶: {plugin_path}")
    
    def run_fix(self) -> Dict[str, Any]:
        """è¿è¡Œä¿®å¤"""
        print("ğŸ”§ å¼€å§‹ä¿®å¤äº‹ä»¶å¾ªç¯é—®é¢˜...")
        
        # 1. æŸ¥æ‰¾å¼‚æ­¥æµ‹è¯•æ–‡ä»¶
        async_files = self.find_async_test_files()
        print(f"ğŸ“ æ‰¾åˆ° {len(async_files)} ä¸ªåŒ…å«å¼‚æ­¥æµ‹è¯•çš„æ–‡ä»¶")
        
        # 2. ä¿®å¤æ¯ä¸ªæ–‡ä»¶
        for file_path in async_files:
            print(f"ğŸ”¨ ä¿®å¤æ–‡ä»¶: {file_path}")
            self.fix_file(file_path)
        
        # 3. åˆ›å»ºpytestæ’ä»¶
        self.create_pytest_plugin()
        
        # 4. è¿”å›ç»“æœ
        result = {
            'fixed_files': len(self.fixed_files),
            'total_files': len(async_files),
            'errors': len(self.errors),
            'success_rate': len(self.fixed_files) / len(async_files) * 100 if async_files else 0
        }
        
        print(f"\nğŸ“Š ä¿®å¤ç»“æœ:")
        print(f"   âœ… æˆåŠŸä¿®å¤: {result['fixed_files']}/{result['total_files']} æ–‡ä»¶")
        print(f"   ğŸ“ˆ æˆåŠŸç‡: {result['success_rate']:.1f}%")
        print(f"   âŒ é”™è¯¯æ•°: {result['errors']}")
        
        if self.errors:
            print(f"\nâ— é”™è¯¯è¯¦æƒ…:")
            for error in self.errors:
                print(f"   - {error}")
        
        return result


def main():
    """ä¸»å‡½æ•°"""
    if len(sys.argv) > 1:
        project_root = sys.argv[1]
    else:
        project_root = os.getcwd()
    
    print(f"ğŸš€ MarketPrismäº‹ä»¶å¾ªç¯é—®é¢˜ä¿®å¤å™¨")
    print(f"ğŸ“‚ é¡¹ç›®æ ¹ç›®å½•: {project_root}")
    
    fixer = EventLoopFixer(project_root)
    result = fixer.run_fix()
    
    if result['success_rate'] > 80:
        print(f"\nğŸ‰ ä¿®å¤æˆåŠŸï¼äº‹ä»¶å¾ªç¯é—®é¢˜å·²åŸºæœ¬è§£å†³")
        return 0
    else:
        print(f"\nâš ï¸  ä¿®å¤éƒ¨åˆ†æˆåŠŸï¼Œè¯·æ£€æŸ¥é”™è¯¯ä¿¡æ¯")
        return 1


if __name__ == "__main__":
    sys.exit(main())