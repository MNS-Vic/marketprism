#!/usr/bin/env python3
"""
ÈîôËØØÂ§ÑÁêÜÁªü‰∏ÄËøÅÁßªËÑöÊú¨

Â∞Üservices‰∏≠ÈáçÂ§çÁöÑÈîôËØØÂ§ÑÁêÜÂÆûÁé∞ËøÅÁßªÂà∞Áªü‰∏Ä‰ΩøÁî®core/errors/Ê®°Âùó
"""

import os
import sys
import shutil
from pathlib import Path
import re
from typing import List, Dict

# Ê∑ªÂä†È°πÁõÆÊ†πÁõÆÂΩïÂà∞Ë∑ØÂæÑ
project_root = Path(__file__).parent.parent.parent
sys.path.insert(0, str(project_root))

class ErrorHandlingMigrator:
    """ÈîôËØØÂ§ÑÁêÜËøÅÁßªÂô®"""
    
    def __init__(self):
        self.project_root = project_root
        self.backup_dir = self.project_root / "backup" / "error_migration"
        self.backup_dir.mkdir(parents=True, exist_ok=True)
        
        # ÈúÄË¶ÅËøÅÁßªÁöÑÊñá‰ª∂
        self.duplicate_files = [
            "services/data-collector/src/marketprism_collector/unified_error_manager.py"
        ]
        
        # ÈúÄË¶ÅÊõ¥Êñ∞ÂØºÂÖ•ÁöÑÊñá‰ª∂
        self.files_to_update = [
            "services/data-collector/src/marketprism_collector/collector.py",
            "services/data-collector/src/marketprism_collector/core_services.py",
            "services/data-collector/src/marketprism_collector/core_integration.py"
        ]
        
        print("üîÑ ÈîôËØØÂ§ÑÁêÜËøÅÁßªÂô®ÂàùÂßãÂåñÂÆåÊàê")
        print(f"üìÅ È°πÁõÆÊ†πÁõÆÂΩï: {self.project_root}")
        print(f"üíæ Â§á‰ªΩÁõÆÂΩï: {self.backup_dir}")
    
    def run_migration(self):
        """ÊâßË°åÂÆåÊï¥ËøÅÁßª"""
        print("\n" + "="*60)
        print("üîÑ ÂºÄÂßãÈîôËØØÂ§ÑÁêÜÁªü‰∏ÄËøÅÁßª")
        print("="*60)
        
        try:
            # 1. Â§á‰ªΩÈáçÂ§çÊñá‰ª∂
            self._backup_duplicate_files()
            
            # 2. ÂàÜÊûêÈáçÂ§ç‰ª£Á†Å
            self._analyze_duplicate_code()
            
            # 3. ÂàõÂª∫ÈÄÇÈÖçÂô®
            self._create_collector_error_adapter()
            
            # 4. Êõ¥Êñ∞ÂØºÂÖ•ÂºïÁî®
            self._update_import_references()
            
            # 5. ÁßªÈô§ÈáçÂ§çÊñá‰ª∂
            self._remove_duplicate_files()
            
            # 6. È™åËØÅËøÅÁßªÁªìÊûú
            self._verify_migration()
            
            print("\n‚úÖ ÈîôËØØÂ§ÑÁêÜËøÅÁßªÂÆåÊàêÔºÅ")
            print("üí° Âª∫ËÆÆËøêË°åÊµãËØïÈ™åËØÅÂäüËÉΩÊ≠£Â∏∏")
            
        except Exception as e:
            print(f"\n‚ùå ËøÅÁßªËøáÁ®ã‰∏≠ÂèëÁîüÈîôËØØ: {e}")
            print("üîÑ Ê≠£Âú®ÂõûÊªö...")
            self._rollback_migration()
            raise
    
    def _backup_duplicate_files(self):
        """Â§á‰ªΩÈáçÂ§çÊñá‰ª∂"""
        print("üíæ Â§á‰ªΩÈáçÂ§çÊñá‰ª∂...")
        
        for file_path in self.duplicate_files:
            source_file = self.project_root / file_path
            if source_file.exists():
                backup_file = self.backup_dir / source_file.name
                shutil.copy2(source_file, backup_file)
                print(f"  üíæ Â§á‰ªΩ {source_file} ‚Üí {backup_file}")
    
    def _analyze_duplicate_code(self):
        """ÂàÜÊûêÈáçÂ§ç‰ª£Á†Å"""
        print("üîç ÂàÜÊûêÈáçÂ§ç‰ª£Á†Å...")
        
        duplicate_file = self.project_root / self.duplicate_files[0]
        if not duplicate_file.exists():
            print("  ‚ö†Ô∏è ÈáçÂ§çÊñá‰ª∂‰∏çÂ≠òÂú®ÔºåË∑≥ËøáÂàÜÊûê")
            return
        
        with open(duplicate_file, 'r', encoding='utf-8') as f:
            content = f.read()
        
        # ÂàÜÊûêÂÖ≥ÈîÆÁ±ªÂíåÂáΩÊï∞
        classes = re.findall(r'class\s+(\w+)', content)
        functions = re.findall(r'def\s+(\w+)', content)
        
        print(f"  üìä ÂèëÁé∞Á±ª: {len(classes)} ‰∏™")
        print(f"  üìä ÂèëÁé∞ÂáΩÊï∞: {len(functions)} ‰∏™")
        print(f"  üìä Êñá‰ª∂Â§ßÂ∞è: {len(content.splitlines())} Ë°å")
        
        # ÂÖ≥ÈîÆÁ±ªÂàÜÊûê
        key_classes = [cls for cls in classes if 'Error' in cls or 'Manager' in cls]
        print(f"  üéØ ÂÖ≥ÈîÆÁ±ª: {key_classes}")
    
    def _create_collector_error_adapter(self):
        """ÂàõÂª∫Êî∂ÈõÜÂô®ÈîôËØØÈÄÇÈÖçÂô®"""
        print("üîß ÂàõÂª∫Êî∂ÈõÜÂô®ÈîôËØØÈÄÇÈÖçÂô®...")
        
        adapter_content = '''"""
MarketPrism Collector ÈîôËØØÂ§ÑÁêÜÈÄÇÈÖçÂô®

Êèê‰æõÊî∂ÈõÜÂô®ÁâπÂÆöÁöÑÈîôËØØÂ§ÑÁêÜÂäüËÉΩÔºåÂü∫‰∫écore/errors/Áªü‰∏ÄÈîôËØØÂ§ÑÁêÜÊ°ÜÊû∂
"""

import logging
from typing import Dict, Any, Optional, List
from datetime import datetime, timezone
from enum import Enum
from dataclasses import dataclass

# ‰ΩøÁî®CoreÈîôËØØÂ§ÑÁêÜÊ®°Âùó
from core.errors import (
    UnifiedErrorHandler, get_global_error_handler,
    MarketPrismError, ErrorCategory, ErrorSeverity, ErrorType,
    ErrorContext, ErrorMetadata
)
from core.reliability import (
    get_reliability_manager,
    MarketPrismCircuitBreaker, CircuitBreakerConfig,
    AdaptiveRateLimiter, RateLimitConfig, RequestPriority
)


class CollectorErrorType(Enum):
    """Êî∂ÈõÜÂô®ÁâπÂÆöÁöÑÈîôËØØÁ±ªÂûã"""
    EXCHANGE_CONNECTION = "exchange_connection"
    WEBSOCKET_DISCONNECTION = "websocket_disconnection"
    DATA_PARSING = "data_parsing"
    NATS_PUBLISH = "nats_publish"
    RATE_LIMIT_EXCEEDED = "rate_limit_exceeded"
    AUTH_FAILURE = "auth_failure"
    SUBSCRIPTION_FAILED = "subscription_failed"
    ADAPTER_CREATION = "adapter_creation"
    HEALTH_CHECK = "health_check"
    ORDERBOOK_PROCESSING = "orderbook_processing"


@dataclass
class ExchangeErrorContext:
    """‰∫§ÊòìÊâÄÈîôËØØ‰∏ä‰∏ãÊñá"""
    exchange_name: str
    symbol: Optional[str] = None
    operation: Optional[str] = None
    retry_count: int = 0
    last_success_time: Optional[datetime] = None
    connection_state: str = "unknown"
    error_frequency: int = 0


class CollectorErrorAdapter:
    """Êî∂ÈõÜÂô®ÈîôËØØÂ§ÑÁêÜÈÄÇÈÖçÂô® - Âü∫‰∫éCoreÈîôËØØÂ§ÑÁêÜÊ°ÜÊû∂"""
    
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        
        # ‰ΩøÁî®CoreÈîôËØØÂ§ÑÁêÜÂô®
        self.error_handler = get_global_error_handler()
        self.reliability_manager = get_reliability_manager()
        
        # Êî∂ÈõÜÂô®ÁâπÂÆöÁöÑ‰∏ä‰∏ãÊñá
        self.exchange_contexts: Dict[str, ExchangeErrorContext] = {}
    
    async def handle_exchange_error(self, 
                                  exchange: str,
                                  error: Exception,
                                  context: Optional[ExchangeErrorContext] = None) -> Dict[str, Any]:
        """Â§ÑÁêÜ‰∫§ÊòìÊâÄÈîôËØØ - ÁÆÄÂåñÁâàÊú¨"""
        
        # ÂàõÂª∫ÊàñÊõ¥Êñ∞‰∏ä‰∏ãÊñá
        if exchange not in self.exchange_contexts:
            self.exchange_contexts[exchange] = ExchangeErrorContext(exchange_name=exchange)
        
        ctx = self.exchange_contexts[exchange]
        if context:
            ctx.symbol = context.symbol or ctx.symbol
            ctx.operation = context.operation or ctx.operation
            ctx.retry_count += 1
        
        # ÂàÜÁ±ªÈîôËØØ
        error_type, severity = self._classify_error(error)
        
        # ËΩ¨Êç¢‰∏∫MarketPrismErrorÂπ∂‰ΩøÁî®CoreÂ§ÑÁêÜÂô®
        marketprism_error = self._convert_to_marketprism_error(
            error, error_type, severity, exchange, ctx
        )
        
        error_id = self.error_handler.handle_error(marketprism_error)
        
        return {
            "error_id": error_id,
            "exchange": exchange,
            "error_type": error_type.value,
            "severity": severity.value,
            "timestamp": datetime.now(timezone.utc).isoformat(),
            "context": {
                "retry_count": ctx.retry_count,
                "symbol": ctx.symbol,
                "operation": ctx.operation
            }
        }
    
    def _classify_error(self, error: Exception) -> tuple:
        """ÂàÜÁ±ªÈîôËØØÁ±ªÂûãÂíå‰∏•ÈáçÊÄß"""
        error_msg = str(error).lower()
        
        if isinstance(error, (ConnectionError, TimeoutError)) or "connection" in error_msg:
            return CollectorErrorType.EXCHANGE_CONNECTION, ErrorSeverity.HIGH
        elif "websocket" in error_msg or "disconnect" in error_msg:
            return CollectorErrorType.WEBSOCKET_DISCONNECTION, ErrorSeverity.MEDIUM
        elif "auth" in error_msg or "unauthorized" in error_msg:
            return CollectorErrorType.AUTH_FAILURE, ErrorSeverity.HIGH
        elif "rate limit" in error_msg or "429" in error_msg:
            return CollectorErrorType.RATE_LIMIT_EXCEEDED, ErrorSeverity.LOW
        elif isinstance(error, (ValueError, KeyError, TypeError)):
            return CollectorErrorType.DATA_PARSING, ErrorSeverity.MEDIUM
        else:
            return CollectorErrorType.EXCHANGE_CONNECTION, ErrorSeverity.MEDIUM
    
    def _convert_to_marketprism_error(self, 
                                    error: Exception,
                                    error_type: CollectorErrorType,
                                    severity: ErrorSeverity,
                                    exchange: str,
                                    context: ExchangeErrorContext) -> MarketPrismError:
        """ËΩ¨Êç¢‰∏∫MarketPrismError"""
        
        metadata = ErrorMetadata(
            error_id=str(id(error)),
            component="collector",
            exchange=exchange,
            symbol=context.symbol,
            operation=context.operation,
            retry_count=context.retry_count,
            first_occurrence=datetime.now(timezone.utc),
            last_occurrence=datetime.now(timezone.utc)
        )
        
        # Êò†Â∞ÑÈîôËØØÁ±ªÂûã
        core_error_type = ErrorType.EXTERNAL_SERVICE_ERROR
        core_category = ErrorCategory.EXTERNAL_SERVICE
        
        if error_type == CollectorErrorType.WEBSOCKET_DISCONNECTION:
            core_error_type = ErrorType.NETWORK_ERROR
            core_category = ErrorCategory.INFRASTRUCTURE
        elif error_type == CollectorErrorType.DATA_PARSING:
            core_error_type = ErrorType.DATA_ERROR
            core_category = ErrorCategory.DATA_PROCESSING
        elif error_type == CollectorErrorType.AUTH_FAILURE:
            core_error_type = ErrorType.AUTHENTICATION_ERROR
            core_category = ErrorCategory.SECURITY
        
        return MarketPrismError(
            message=f"[{exchange}] {error_type.value}: {str(error)}",
            error_type=core_error_type,
            category=core_category,
            severity=severity,
            metadata=metadata,
            cause=error
        )


# ÂÖ®Â±ÄÂÆû‰æã
collector_error_adapter = CollectorErrorAdapter()


# ‰æøÂà©ÂáΩÊï∞
async def handle_collector_error(exchange: str, error: Exception, **kwargs):
    """Â§ÑÁêÜÊî∂ÈõÜÂô®ÈîôËØØÁöÑ‰æøÂà©ÂáΩÊï∞"""
    return await collector_error_adapter.handle_exchange_error(exchange, error, **kwargs)


def log_collector_error(message: str, **kwargs):
    """ËÆ∞ÂΩïÊî∂ÈõÜÂô®ÈîôËØØÁöÑ‰æøÂà©ÂáΩÊï∞"""
    logger = logging.getLogger("collector_error")
    logger.error(message, **kwargs)
'''
        
        adapter_file = self.project_root / "services/data-collector/src/marketprism_collector/error_adapter.py"
        with open(adapter_file, 'w', encoding='utf-8') as f:
            f.write(adapter_content)
        
        print(f"  ‚úÖ ÂàõÂª∫ÈÄÇÈÖçÂô®: {adapter_file}")
    
    def _update_import_references(self):
        """Êõ¥Êñ∞ÂØºÂÖ•ÂºïÁî®"""
        print("üîß Êõ¥Êñ∞ÂØºÂÖ•ÂºïÁî®...")
        
        # ÂØºÂÖ•Êò†Â∞Ñ
        import_mappings = {
            "from marketprism_collector.unified_error_manager import": "from marketprism_collector.error_adapter import",
            "from .unified_error_manager import": "from .error_adapter import",
            "CollectorErrorManager": "CollectorErrorAdapter",
            "unified_error_manager": "error_adapter"
        }
        
        for file_path in self.files_to_update:
            file_full_path = self.project_root / file_path
            if file_full_path.exists():
                try:
                    with open(file_full_path, 'r', encoding='utf-8') as f:
                        content = f.read()
                    
                    # Â∫îÁî®Êò†Â∞Ñ
                    updated = False
                    for old_import, new_import in import_mappings.items():
                        if old_import in content:
                            content = content.replace(old_import, new_import)
                            updated = True
                    
                    if updated:
                        with open(file_full_path, 'w', encoding='utf-8') as f:
                            f.write(content)
                        print(f"  ‚úÖ Êõ¥Êñ∞ÂØºÂÖ•: {file_full_path}")
                
                except Exception as e:
                    print(f"  ‚ö†Ô∏è Êõ¥Êñ∞ {file_full_path} Â§±Ë¥•: {e}")
    
    def _remove_duplicate_files(self):
        """ÁßªÈô§ÈáçÂ§çÊñá‰ª∂"""
        print("üóëÔ∏è ÁßªÈô§ÈáçÂ§çÊñá‰ª∂...")
        
        for file_path in self.duplicate_files:
            file_full_path = self.project_root / file_path
            if file_full_path.exists():
                file_full_path.unlink()
                print(f"  üóëÔ∏è Âà†Èô§: {file_full_path}")
    
    def _verify_migration(self):
        """È™åËØÅËøÅÁßªÁªìÊûú"""
        print("‚úÖ È™åËØÅËøÅÁßªÁªìÊûú...")
        
        # Ê£ÄÊü•ÈÄÇÈÖçÂô®Êñá‰ª∂ÊòØÂê¶Â≠òÂú®
        adapter_file = self.project_root / "services/data-collector/src/marketprism_collector/error_adapter.py"
        if adapter_file.exists():
            print("  ‚úÖ ÈÄÇÈÖçÂô®Êñá‰ª∂ÂàõÂª∫ÊàêÂäü")
        else:
            print("  ‚ùå ÈÄÇÈÖçÂô®Êñá‰ª∂ÂàõÂª∫Â§±Ë¥•")
        
        # Ê£ÄÊü•ÈáçÂ§çÊñá‰ª∂ÊòØÂê¶Â∑≤Âà†Èô§
        for file_path in self.duplicate_files:
            file_full_path = self.project_root / file_path
            if not file_full_path.exists():
                print(f"  ‚úÖ ÈáçÂ§çÊñá‰ª∂Â∑≤Âà†Èô§: {file_path}")
            else:
                print(f"  ‚ùå ÈáçÂ§çÊñá‰ª∂‰ªçÂ≠òÂú®: {file_path}")
    
    def _rollback_migration(self):
        """ÂõûÊªöËøÅÁßª"""
        print("üîÑ ÂõûÊªöËøÅÁßª...")
        
        # ÊÅ¢Â§çÂ§á‰ªΩÊñá‰ª∂
        for file_path in self.duplicate_files:
            source_file = self.project_root / file_path
            backup_file = self.backup_dir / Path(file_path).name
            
            if backup_file.exists():
                shutil.copy2(backup_file, source_file)
                print(f"  üîÑ ÊÅ¢Â§ç: {backup_file} ‚Üí {source_file}")


def main():
    """‰∏ªÂáΩÊï∞"""
    migrator = ErrorHandlingMigrator()
    
    try:
        migrator.run_migration()
        print("\nüéØ ÈîôËØØÂ§ÑÁêÜËøÅÁßªÊàêÂäüÂÆåÊàêÔºÅ")
        print("üìã ‰∏ã‰∏ÄÊ≠•Âª∫ËÆÆ:")
        print("  1. ËøêË°åÊµãËØïÈ™åËØÅÂäüËÉΩÊ≠£Â∏∏")
        print("  2. Ê£ÄÊü•Êó•ÂøóÁ°ÆËÆ§ÈîôËØØÂ§ÑÁêÜÂ∑•‰ΩúÊ≠£Â∏∏")
        print("  3. ÁªßÁª≠ËøõË°åÂèØÈù†ÊÄßÁÆ°ÁêÜÁªü‰∏ÄËøÅÁßª")
        
    except Exception as e:
        print(f"\n‚ùå ËøÅÁßªÂ§±Ë¥•: {e}")
        import traceback
        traceback.print_exc()
        return 1
    
    return 0


if __name__ == "__main__":
    sys.exit(main())
